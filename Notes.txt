MDPRemoteController can also act as a bluetooth server since AMDTool always acts as client
 Connect button allows choosing between connecting to a PC (as a client), or starts a listening socket and waits for AMD tool to connect (as a server). When AMD tool disconnects, the app stays in “waiting for reconnect” and accepts the next connection automatically

Status updates
String prefixes: parseStatusLine()
"MSG,",
"status=",
"STATUS,",
"STATUS:",
"ROBOTSTATUS,",
"ROBOT_STATUS,",
"Robot Status:"

Each obstacle must have a unique obstacle number. Optionally, an obstacle can be assigned a unique target ID. If an obstacle has a target ID, it will display it in large font when the robot has scanned it, otherwise it will display its obstacle number in small font

Realistic movement mode to simulate acceleration/turning

3d overhead third-person view

Extra feature: Save and load arena layouts, export/receive via bluetooth

Extra feature: Arena supports pinch to zoom and drag to pan, to enable larger arena sizes

Extra feature: Can receive bluetooth messages to control robot and edit obstacles, arena and robot size
FORWARD BACKWARD TURN_LEFT TURN_RIGHT
OBS,ADD,<num>,<x>,<y>,<size>
OBS,MOVE,<num>,<x>,<y>
OBS,DEL,<num>
OBS,SIZE,<num>,<size>
OBS,NUM,<old>,<new>
TARGET,ADD,<num>,<N|E|S|W>
TARGET,CLEAR,<num>
ARENA,SIZE,<width>,<height>
ROBOT,SIZE,<size>
Set/Clear target ID: TARGET,<num>,<targetID> (0 to clear)
Update robot position/orientation: ROBOT,<x>,<y>,<N|E|S|W>

Extra feature: Time trial
 Manually control robot to reach all targets, compare score with computer opponent

Extra feature: Additional movement options
Virtual joystick, device tilt, Tap‑to‑move




Realistic mode fastest path
In realistic mode, shortest/fastest paths are computed on a discrete state graph using Dijkstra’s algorithm. Each state represents the robot’s grid cell and facing direction. Movement is constrained to 4 action types:

F = move forward one cell
B = move backward one cell
L = turn left and move to the forward‑left diagonal cell
R = turn right and move to the forward‑right diagonal cell
There are no in‑place turns in realistic mode. Left/right are quarter‑circle turns that advance diagonally. This matches the “turning radius” requirement while remaining grid‑aligned.

State representation
File: MainActivity.java

State index encoding:

private int stateIndex(int x, int y, int dir, int width) {
    return ((y * width + x) * 4) + dir;
}
x, y = robot’s grid cell
dir in {0,1,2,3} = North, East, South, West
total states = width * height * 4
Decode:

private int[] decodeState(int state, int width)
Movement model
Cardinal forward/back deltas
private int[] dirToDelta(int dir)
Returns one‑cell delta for forward:

N → (0,+1)
E → (+1,0)
S → (0,-1)
W → (-1,0)
Diagonal turn deltas
private int[] turnDelta(int dir, boolean left)
This encodes the diagonal landing cell after a quarter‑turn:

Let (dx, dy) = forward delta.
Left diagonal = (dx - dy, dy + dx)
Right diagonal = (dx + dy, dy - dx)

Examples:

Facing North (0,+1)
Left → (-1,+1), Right → (+1,+1)
Facing East (+1,0)
Left → (+1,+1), Right → (+1,-1)
Facing South (0,-1)
Left → (+1,-1), Right → (-1,-1)
Facing West (-1,0)
Left → (-1,-1), Right → (-1,+1)
Corner‑collision check
Diagonal turns are blocked if they “cut a corner”.
We require three placements to be valid:

the diagonal target cell
the forward adjacent cell
the side adjacent cell
private boolean isDiagonalTurnClear(int x, int y, int dir, boolean left)
This prevents the robot from slipping past obstacle corners.

Dijkstra: shortest‑time path in realistic mode
Function: dijkstraDistances(...)
Computes shortest‑time distance from a start state to all states.

For each state (x,y,dir), outgoing edges:

F: (x+dx, y+dy, dir)
B: (x-dx, y-dy, dir)
L: (x+ldx, y+ldy, (dir+3)%4) (only if isDiagonalTurnClear)
R: (x+rdx, y+rdy, (dir+1)%4) (only if isDiagonalTurnClear)
Weights are time from actionDurationSeconds(char action).

Function: dijkstraActions(...)
Same transitions, but also stores prev[] and prevAction[] so we can reconstruct the optimal action list.

Action time model (realistic)
private double actionDurationSeconds(char action)
For realistic mode:

F / B: time = 1 / speed + accelPenalty
L / R: time = (π/2 * radius) / speed + accelPenalty*1.5
Speed is derived from the current simulation settings:

simMaxSpeed (top speed)
simAccel (acceleration)
These values are editable in Edit Arena & Robot Sizes.

Where it’s used
1) Find Fastest Path
computeShortestPath() (realistic mode path cost):

For each target, compute approach states.
Use Dijkstra (time weights) between states.
DP bitmask over target sets (Hamiltonian visiting all targets).
Result = optimal action list, time computed by computePathTimeSeconds.
2) Tap‑to‑Move (realistic)
moveRobotTo(x,y):

Runs Dijkstra from current state to target cell (any dir).
Reconstructs the action list.
Plays each action with playRealisticAction.
3) Playback
playRealisticAction(char action, Runnable onDone)

F/B: linear move to next cell
L/R: quarter‑circle arc to diagonal cell
Ends snapped on grid; heading rotated by ±90°
Summary of key functions / vars
State / transitions

stateIndex(...)
decodeState(...)
dirToDelta(...)
turnDelta(...)
isDiagonalTurnClear(...)
Realistic shortest path

dijkstraDistances(...)
dijkstraActions(...)
Timing

actionDurationSeconds(...)
computePathTimeSeconds(...)
Playback

playRealisticAction(...)



Simplified mode:
Shortest path computation:
Shortest Hamiltonian Path over targets, where each movement action has cost 1 (forward, backward, rotate left, rotate right). The robot “scans” a target when it is adjacent to that obstacle face and facing it.

Build reachable robot states for each target face
collectTargets() gathers each target face as a Target object (obstacle + face N/E/S/W).
buildApproachStates(Target t, width, height) computes all robot poses (x, y, direction) that are valid for scanning that face.
Each valid pose becomes a state encoded as (x, y, dir).

Compute shortest path between poses using BFS
States are encoded as an index: stateIndex(x, y, dir, width).
BFS over the grid + orientation gives shortest action cost:
bfsDistances(startState, width, height, totalStates) returns distance to all states.
bfsActions(startState, goalState, width, height, totalStates) returns the actual action sequence (F/B/L/R).

Dynamic programming over targets (TSP-style)
We treat each target face as a “node,” but each node has multiple valid approach states.
We create approachStates (all approach poses) and targetToApproachIdx (mapping from target → list of indices in approachStates).
DP table:
dp[mask][s]: minimum cost to cover target set mask and end at approach state s.
prevState, prevMask: backpointers to reconstruct the best end state sequence.
After DP completes, we reconstruct the optimal sequence of approach states, then stitch together the BFS action sequences between consecutive states.

Key functions & variables

computeShortestPath()
Orchestrates everything (targets → approach states → BFS distances → DP → path actions).
collectTargets()
Reads targets from arenaView.getObstaclesSnapshot() and target face flags.
buildApproachStates(Target t, int width, int height)
Generates all valid “scan poses” for a specific target face.
bfsDistances(...)
BFS for costs between pose states.
bfsActions(...)
BFS that returns action steps (F/B/L/R) for animation.
pathActions
The final action list used by playback.
pathIndex, pathPlaying
Playback progress state.

State and movement model

State = (x, y, dir) where dir ∈ {0:N, 1:E, 2:S, 3:W}.
Actions cost 1:
L rotate left, R rotate right
F move forward, B move backward
All movement is blocked if the robot footprint would collide with obstacles or leave the arena.
BFS neighbors:
(x, y, (dir+3)%4) by L
(x, y, (dir+1)%4) by R
(x+dx, y+dy, dir) by F
(x-dx, y-dy, dir) by B

Why this is shortest

BFS ensures shortest action paths between any two states.
DP over bitmasks ensures the globally shortest sequence that visits (scans) all targets, measured in total actions.